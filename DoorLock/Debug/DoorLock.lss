
DoorLock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000474  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000022  00800060  00000474  00000508  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000f  00800082  00800082  0000052a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000052a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000c0  00000000  00000000  0000055a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000b38  00000000  00000000  0000061a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000299  00000000  00000000  00001152  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000003b1  00000000  00000000  000013eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000018c  00000000  00000000  0000179c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000348  00000000  00000000  00001928  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000616  00000000  00000000  00001c70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000b0  00000000  00000000  00002286  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	12 c0       	rjmp	.+36     	; 0x26 <__ctors_end>
   2:	2c c0       	rjmp	.+88     	; 0x5c <__bad_interrupt>
   4:	2b c0       	rjmp	.+86     	; 0x5c <__bad_interrupt>
   6:	2a c0       	rjmp	.+84     	; 0x5c <__bad_interrupt>
   8:	29 c0       	rjmp	.+82     	; 0x5c <__bad_interrupt>
   a:	28 c0       	rjmp	.+80     	; 0x5c <__bad_interrupt>
   c:	27 c0       	rjmp	.+78     	; 0x5c <__bad_interrupt>
   e:	26 c0       	rjmp	.+76     	; 0x5c <__bad_interrupt>
  10:	25 c0       	rjmp	.+74     	; 0x5c <__bad_interrupt>
  12:	24 c0       	rjmp	.+72     	; 0x5c <__bad_interrupt>
  14:	23 c0       	rjmp	.+70     	; 0x5c <__bad_interrupt>
  16:	22 c0       	rjmp	.+68     	; 0x5c <__bad_interrupt>
  18:	21 c0       	rjmp	.+66     	; 0x5c <__bad_interrupt>
  1a:	20 c0       	rjmp	.+64     	; 0x5c <__bad_interrupt>
  1c:	1f c0       	rjmp	.+62     	; 0x5c <__bad_interrupt>
  1e:	1e c0       	rjmp	.+60     	; 0x5c <__bad_interrupt>
  20:	1d c0       	rjmp	.+58     	; 0x5c <__bad_interrupt>
  22:	1c c0       	rjmp	.+56     	; 0x5c <__bad_interrupt>
  24:	1b c0       	rjmp	.+54     	; 0x5c <__bad_interrupt>

00000026 <__ctors_end>:
  26:	11 24       	eor	r1, r1
  28:	1f be       	out	0x3f, r1	; 63
  2a:	cf e5       	ldi	r28, 0x5F	; 95
  2c:	d4 e0       	ldi	r29, 0x04	; 4
  2e:	de bf       	out	0x3e, r29	; 62
  30:	cd bf       	out	0x3d, r28	; 61

00000032 <__do_copy_data>:
  32:	10 e0       	ldi	r17, 0x00	; 0
  34:	a0 e6       	ldi	r26, 0x60	; 96
  36:	b0 e0       	ldi	r27, 0x00	; 0
  38:	e4 e7       	ldi	r30, 0x74	; 116
  3a:	f4 e0       	ldi	r31, 0x04	; 4
  3c:	02 c0       	rjmp	.+4      	; 0x42 <__SREG__+0x3>
  3e:	05 90       	lpm	r0, Z+
  40:	0d 92       	st	X+, r0
  42:	a2 38       	cpi	r26, 0x82	; 130
  44:	b1 07       	cpc	r27, r17
  46:	d9 f7       	brne	.-10     	; 0x3e <__SP_H__>

00000048 <__do_clear_bss>:
  48:	20 e0       	ldi	r18, 0x00	; 0
  4a:	a2 e8       	ldi	r26, 0x82	; 130
  4c:	b0 e0       	ldi	r27, 0x00	; 0
  4e:	01 c0       	rjmp	.+2      	; 0x52 <.do_clear_bss_start>

00000050 <.do_clear_bss_loop>:
  50:	1d 92       	st	X+, r1

00000052 <.do_clear_bss_start>:
  52:	a1 39       	cpi	r26, 0x91	; 145
  54:	b2 07       	cpc	r27, r18
  56:	e1 f7       	brne	.-8      	; 0x50 <.do_clear_bss_loop>
  58:	b4 d1       	rcall	.+872    	; 0x3c2 <main>
  5a:	0a c2       	rjmp	.+1044   	; 0x470 <_exit>

0000005c <__bad_interrupt>:
  5c:	d1 cf       	rjmp	.-94     	; 0x0 <__vectors>

0000005e <_LCD_OutNibble>:
// Funkcja wystawiaj¹ca pó³bajt na magistralê danych
//
//-------------------------------------------------------------------------------------------------
void _LCD_OutNibble(unsigned char nibbleToWrite)
{
if(nibbleToWrite & 0x01)
  5e:	80 ff       	sbrs	r24, 0
  60:	02 c0       	rjmp	.+4      	; 0x66 <_LCD_OutNibble+0x8>
	LCD_DB4_PORT |= LCD_DB4;
  62:	aa 9a       	sbi	0x15, 2	; 21
  64:	01 c0       	rjmp	.+2      	; 0x68 <_LCD_OutNibble+0xa>
else
	LCD_DB4_PORT  &= ~LCD_DB4;
  66:	aa 98       	cbi	0x15, 2	; 21

if(nibbleToWrite & 0x02)
  68:	81 ff       	sbrs	r24, 1
  6a:	02 c0       	rjmp	.+4      	; 0x70 <_LCD_OutNibble+0x12>
	LCD_DB5_PORT |= LCD_DB5;
  6c:	ab 9a       	sbi	0x15, 3	; 21
  6e:	01 c0       	rjmp	.+2      	; 0x72 <_LCD_OutNibble+0x14>
else
	LCD_DB5_PORT  &= ~LCD_DB5;
  70:	ab 98       	cbi	0x15, 3	; 21

if(nibbleToWrite & 0x04)
  72:	82 ff       	sbrs	r24, 2
  74:	02 c0       	rjmp	.+4      	; 0x7a <_LCD_OutNibble+0x1c>
	LCD_DB6_PORT |= LCD_DB6;
  76:	ac 9a       	sbi	0x15, 4	; 21
  78:	01 c0       	rjmp	.+2      	; 0x7c <_LCD_OutNibble+0x1e>
else
	LCD_DB6_PORT  &= ~LCD_DB6;
  7a:	ac 98       	cbi	0x15, 4	; 21

if(nibbleToWrite & 0x08)
  7c:	83 ff       	sbrs	r24, 3
  7e:	02 c0       	rjmp	.+4      	; 0x84 <_LCD_OutNibble+0x26>
	LCD_DB7_PORT |= LCD_DB7;
  80:	ad 9a       	sbi	0x15, 5	; 21
  82:	08 95       	ret
else
	LCD_DB7_PORT  &= ~LCD_DB7;
  84:	ad 98       	cbi	0x15, 5	; 21
  86:	08 95       	ret

00000088 <_LCD_Write>:
//
// Funkcja zapisu bajtu do wyœwietacza (bez rozró¿nienia instrukcja/dane).
//
//-------------------------------------------------------------------------------------------------
void _LCD_Write(unsigned char dataToWrite)
{
  88:	cf 93       	push	r28
  8a:	c8 2f       	mov	r28, r24
LCD_E_PORT |= LCD_E;
  8c:	a9 9a       	sbi	0x15, 1	; 21
_LCD_OutNibble(dataToWrite >> 4);
  8e:	82 95       	swap	r24
  90:	8f 70       	andi	r24, 0x0F	; 15
  92:	e5 df       	rcall	.-54     	; 0x5e <_LCD_OutNibble>
LCD_E_PORT &= ~LCD_E;
  94:	a9 98       	cbi	0x15, 1	; 21
LCD_E_PORT |= LCD_E;
  96:	a9 9a       	sbi	0x15, 1	; 21
_LCD_OutNibble(dataToWrite);
  98:	8c 2f       	mov	r24, r28
  9a:	e1 df       	rcall	.-62     	; 0x5e <_LCD_OutNibble>
LCD_E_PORT &= ~LCD_E;
  9c:	a9 98       	cbi	0x15, 1	; 21
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  9e:	85 e8       	ldi	r24, 0x85	; 133
  a0:	8a 95       	dec	r24
  a2:	f1 f7       	brne	.-4      	; 0xa0 <_LCD_Write+0x18>
  a4:	00 00       	nop
_delay_us(50);
}
  a6:	cf 91       	pop	r28
  a8:	08 95       	ret

000000aa <LCD_WriteCommand>:
// Funkcja zapisu rozkazu do wyœwietlacza
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteCommand(unsigned char commandToWrite)
{
LCD_RS_PORT &= ~LCD_RS;
  aa:	a8 98       	cbi	0x15, 0	; 21
_LCD_Write(commandToWrite);
  ac:	ed df       	rcall	.-38     	; 0x88 <_LCD_Write>
  ae:	08 95       	ret

000000b0 <LCD_WriteData>:
// Funkcja zapisu danych do pamiêci wyœwietlacza
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteData(unsigned char dataToWrite)
{
LCD_RS_PORT |= LCD_RS;
  b0:	a8 9a       	sbi	0x15, 0	; 21
_LCD_Write(dataToWrite);
  b2:	ea df       	rcall	.-44     	; 0x88 <_LCD_Write>
  b4:	08 95       	ret

000000b6 <LCD_WriteText>:
//
// Funkcja wyœwietlenia napisu na wyswietlaczu.
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteText(char * text)
{
  b6:	cf 93       	push	r28
  b8:	df 93       	push	r29
  ba:	ec 01       	movw	r28, r24
while(*text)
  bc:	88 81       	ld	r24, Y
  be:	88 23       	and	r24, r24
  c0:	29 f0       	breq	.+10     	; 0xcc <LCD_WriteText+0x16>
  c2:	21 96       	adiw	r28, 0x01	; 1
  LCD_WriteData(*text++);
  c4:	f5 df       	rcall	.-22     	; 0xb0 <LCD_WriteData>
// Funkcja wyœwietlenia napisu na wyswietlaczu.
//
//-------------------------------------------------------------------------------------------------
void LCD_WriteText(char * text)
{
while(*text)
  c6:	89 91       	ld	r24, Y+
  c8:	81 11       	cpse	r24, r1
  ca:	fc cf       	rjmp	.-8      	; 0xc4 <LCD_WriteText+0xe>
  LCD_WriteData(*text++);
}
  cc:	df 91       	pop	r29
  ce:	cf 91       	pop	r28
  d0:	08 95       	ret

000000d2 <LCD_Initalize>:
//
// Procedura inicjalizacji kontrolera HD44780.
//
//-------------------------------------------------------------------------------------------------
void LCD_Initalize(void)
{
  d2:	cf 93       	push	r28
unsigned char i;
LCD_DB4_DIR |= LCD_DB4; // Konfiguracja kierunku pracy wyprowadzeñ
  d4:	a2 9a       	sbi	0x14, 2	; 20
LCD_DB5_DIR |= LCD_DB5; //
  d6:	a3 9a       	sbi	0x14, 3	; 20
LCD_DB6_DIR |= LCD_DB6; //
  d8:	a4 9a       	sbi	0x14, 4	; 20
LCD_DB7_DIR |= LCD_DB7; //
  da:	a5 9a       	sbi	0x14, 5	; 20
LCD_E_DIR 	|= LCD_E;   //
  dc:	a1 9a       	sbi	0x14, 1	; 20
LCD_RS_DIR 	|= LCD_RS;  //
  de:	a0 9a       	sbi	0x14, 0	; 20
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  e0:	8f e2       	ldi	r24, 0x2F	; 47
  e2:	95 e7       	ldi	r25, 0x75	; 117
  e4:	01 97       	sbiw	r24, 0x01	; 1
  e6:	f1 f7       	brne	.-4      	; 0xe4 <LCD_Initalize+0x12>
  e8:	00 c0       	rjmp	.+0      	; 0xea <LCD_Initalize+0x18>
  ea:	00 00       	nop
_delay_ms(15); // oczekiwanie na ustalibizowanie siê napiecia zasilajacego
LCD_RS_PORT &= ~LCD_RS; // wyzerowanie linii RS
  ec:	a8 98       	cbi	0x15, 0	; 21
LCD_E_PORT &= ~LCD_E;  // wyzerowanie linii E
  ee:	a9 98       	cbi	0x15, 1	; 21
  f0:	c3 e0       	ldi	r28, 0x03	; 3

for(i = 0; i < 3; i++) // trzykrotne powtórzenie bloku instrukcji
  {
  LCD_E_PORT |= LCD_E; //  E = 1
  f2:	a9 9a       	sbi	0x15, 1	; 21
  _LCD_OutNibble(0x03); // tryb 8-bitowy
  f4:	83 e0       	ldi	r24, 0x03	; 3
  f6:	b3 df       	rcall	.-154    	; 0x5e <_LCD_OutNibble>
  LCD_E_PORT &= ~LCD_E; // E = 0
  f8:	a9 98       	cbi	0x15, 1	; 21
  fa:	8f e0       	ldi	r24, 0x0F	; 15
  fc:	97 e2       	ldi	r25, 0x27	; 39
  fe:	01 97       	sbiw	r24, 0x01	; 1
 100:	f1 f7       	brne	.-4      	; 0xfe <LCD_Initalize+0x2c>
 102:	00 c0       	rjmp	.+0      	; 0x104 <LCD_Initalize+0x32>
 104:	00 00       	nop
 106:	c1 50       	subi	r28, 0x01	; 1
LCD_RS_DIR 	|= LCD_RS;  //
_delay_ms(15); // oczekiwanie na ustalibizowanie siê napiecia zasilajacego
LCD_RS_PORT &= ~LCD_RS; // wyzerowanie linii RS
LCD_E_PORT &= ~LCD_E;  // wyzerowanie linii E

for(i = 0; i < 3; i++) // trzykrotne powtórzenie bloku instrukcji
 108:	a1 f7       	brne	.-24     	; 0xf2 <LCD_Initalize+0x20>
  _LCD_OutNibble(0x03); // tryb 8-bitowy
  LCD_E_PORT &= ~LCD_E; // E = 0
  _delay_ms(5); // czekaj 5ms
  }

LCD_E_PORT |= LCD_E; // E = 1
 10a:	a9 9a       	sbi	0x15, 1	; 21
_LCD_OutNibble(0x02); // tryb 4-bitowy
 10c:	82 e0       	ldi	r24, 0x02	; 2
 10e:	a7 df       	rcall	.-178    	; 0x5e <_LCD_OutNibble>
LCD_E_PORT &= ~LCD_E; // E = 0
 110:	a9 98       	cbi	0x15, 1	; 21
 112:	8f ec       	ldi	r24, 0xCF	; 207
 114:	97 e0       	ldi	r25, 0x07	; 7
 116:	01 97       	sbiw	r24, 0x01	; 1
 118:	f1 f7       	brne	.-4      	; 0x116 <LCD_Initalize+0x44>
 11a:	00 c0       	rjmp	.+0      	; 0x11c <LCD_Initalize+0x4a>
 11c:	00 00       	nop

_delay_ms(1); // czekaj 1ms 
LCD_WriteCommand(HD44780_FUNCTION_SET | HD44780_FONT5x7 | HD44780_TWO_LINE | HD44780_4_BIT); // interfejs 4-bity, 2-linie, znak 5x7
 11e:	88 e2       	ldi	r24, 0x28	; 40
 120:	c4 df       	rcall	.-120    	; 0xaa <LCD_WriteCommand>
LCD_WriteCommand(HD44780_DISPLAY_ONOFF | HD44780_DISPLAY_OFF); // wy³¹czenie wyswietlacza
 122:	88 e0       	ldi	r24, 0x08	; 8
 124:	c2 df       	rcall	.-124    	; 0xaa <LCD_WriteCommand>
LCD_WriteCommand(HD44780_CLEAR); // czyszczenie zawartosæi pamieci DDRAM
 126:	81 e0       	ldi	r24, 0x01	; 1
 128:	c0 df       	rcall	.-128    	; 0xaa <LCD_WriteCommand>
 12a:	8f e9       	ldi	r24, 0x9F	; 159
 12c:	9f e0       	ldi	r25, 0x0F	; 15
 12e:	01 97       	sbiw	r24, 0x01	; 1
 130:	f1 f7       	brne	.-4      	; 0x12e <LCD_Initalize+0x5c>
 132:	00 c0       	rjmp	.+0      	; 0x134 <LCD_Initalize+0x62>
 134:	00 00       	nop
_delay_ms(2);
LCD_WriteCommand(HD44780_ENTRY_MODE | HD44780_EM_SHIFT_CURSOR | HD44780_EM_INCREMENT);// inkrementaja adresu i przesuwanie kursora
 136:	86 e0       	ldi	r24, 0x06	; 6
 138:	b8 df       	rcall	.-144    	; 0xaa <LCD_WriteCommand>
LCD_WriteCommand(HD44780_DISPLAY_ONOFF | HD44780_DISPLAY_ON | HD44780_CURSOR_OFF | HD44780_CURSOR_NOBLINK); // w³¹cz LCD, bez kursora i mrugania
 13a:	8c e0       	ldi	r24, 0x0C	; 12
 13c:	b6 df       	rcall	.-148    	; 0xaa <LCD_WriteCommand>
}
 13e:	cf 91       	pop	r28
 140:	08 95       	ret

00000142 <setPorts>:
void setPorts(volatile uint8_t *, volatile uint8_t *, volatile uint8_t *);
char pushKey();

void setPorts(volatile uint8_t * ddr, volatile uint8_t * port, volatile uint8_t * pin) {
	
	KEYBOARD_DDR = ddr;
 142:	90 93 88 00 	sts	0x0088, r25
 146:	80 93 87 00 	sts	0x0087, r24
	KEYBOARD_PORT = port;
 14a:	70 93 86 00 	sts	0x0086, r23
 14e:	60 93 85 00 	sts	0x0085, r22
	KEYBOARD_PIN = pin;
 152:	50 93 84 00 	sts	0x0084, r21
 156:	40 93 83 00 	sts	0x0083, r20
	
	*KEYBOARD_DDR = 0b00001111;
 15a:	2f e0       	ldi	r18, 0x0F	; 15
 15c:	fc 01       	movw	r30, r24
 15e:	20 83       	st	Z, r18
	*KEYBOARD_PORT = 0b11111111;
 160:	e0 91 85 00 	lds	r30, 0x0085
 164:	f0 91 86 00 	lds	r31, 0x0086
 168:	8f ef       	ldi	r24, 0xFF	; 255
 16a:	80 83       	st	Z, r24
 16c:	08 95       	ret

0000016e <pushKey>:
}

char pushKey() {
 16e:	cf 93       	push	r28
 170:	df 93       	push	r29
	int i, j;
	
	for(i = 0; i < 4; i++)
 172:	60 e0       	ldi	r22, 0x00	; 0
 174:	70 e0       	ldi	r23, 0x00	; 0
	{
		*KEYBOARD_PORT &= ~(1 << i);
 176:	c1 e0       	ldi	r28, 0x01	; 1
 178:	d0 e0       	ldi	r29, 0x00	; 0
 17a:	e0 91 85 00 	lds	r30, 0x0085
 17e:	f0 91 86 00 	lds	r31, 0x0086
 182:	80 81       	ld	r24, Z
 184:	de 01       	movw	r26, r28
 186:	06 2e       	mov	r0, r22
 188:	02 c0       	rjmp	.+4      	; 0x18e <pushKey+0x20>
 18a:	aa 0f       	add	r26, r26
 18c:	bb 1f       	adc	r27, r27
 18e:	0a 94       	dec	r0
 190:	e2 f7       	brpl	.-8      	; 0x18a <pushKey+0x1c>
 192:	9a 2f       	mov	r25, r26
 194:	90 95       	com	r25
 196:	89 23       	and	r24, r25
 198:	80 83       	st	Z, r24

		for(j = 0; j < 4; j++)
		{
			if(!(*KEYBOARD_PIN & (1 << (j + 4)))) // jest stan LOW
 19a:	e0 91 83 00 	lds	r30, 0x0083
 19e:	f0 91 84 00 	lds	r31, 0x0084
 1a2:	80 81       	ld	r24, Z
 1a4:	84 ff       	sbrs	r24, 4
 1a6:	0f c0       	rjmp	.+30     	; 0x1c6 <pushKey+0x58>
	
	for(i = 0; i < 4; i++)
	{
		*KEYBOARD_PORT &= ~(1 << i);

		for(j = 0; j < 4; j++)
 1a8:	ce 01       	movw	r24, r28
		{
			if(!(*KEYBOARD_PIN & (1 << (j + 4)))) // jest stan LOW
 1aa:	40 81       	ld	r20, Z
 1ac:	9c 01       	movw	r18, r24
 1ae:	2c 5f       	subi	r18, 0xFC	; 252
 1b0:	3f 4f       	sbci	r19, 0xFF	; 255
 1b2:	50 e0       	ldi	r21, 0x00	; 0
 1b4:	02 2e       	mov	r0, r18
 1b6:	02 c0       	rjmp	.+4      	; 0x1bc <pushKey+0x4e>
 1b8:	55 95       	asr	r21
 1ba:	47 95       	ror	r20
 1bc:	0a 94       	dec	r0
 1be:	e2 f7       	brpl	.-8      	; 0x1b8 <pushKey+0x4a>
 1c0:	40 fd       	sbrc	r20, 0
 1c2:	2f c0       	rjmp	.+94     	; 0x222 <pushKey+0xb4>
 1c4:	04 c0       	rjmp	.+8      	; 0x1ce <pushKey+0x60>
 1c6:	24 e0       	ldi	r18, 0x04	; 4
 1c8:	30 e0       	ldi	r19, 0x00	; 0
	
	for(i = 0; i < 4; i++)
	{
		*KEYBOARD_PORT &= ~(1 << i);

		for(j = 0; j < 4; j++)
 1ca:	80 e0       	ldi	r24, 0x00	; 0
 1cc:	90 e0       	ldi	r25, 0x00	; 0
		{
			if(!(*KEYBOARD_PIN & (1 << (j + 4)))) // jest stan LOW
			{
				char key = keyboard[3 - j][3 - i];
 1ce:	43 e0       	ldi	r20, 0x03	; 3
 1d0:	50 e0       	ldi	r21, 0x00	; 0
 1d2:	fa 01       	movw	r30, r20
 1d4:	e8 1b       	sub	r30, r24
 1d6:	f9 0b       	sbc	r31, r25
 1d8:	46 1b       	sub	r20, r22
 1da:	57 0b       	sbc	r21, r23
 1dc:	ee 0f       	add	r30, r30
 1de:	ff 1f       	adc	r31, r31
 1e0:	ee 0f       	add	r30, r30
 1e2:	ff 1f       	adc	r31, r31
 1e4:	e4 0f       	add	r30, r20
 1e6:	f5 1f       	adc	r31, r21
 1e8:	ee 59       	subi	r30, 0x9E	; 158
 1ea:	ff 4f       	sbci	r31, 0xFF	; 255
 1ec:	80 81       	ld	r24, Z
 1ee:	ef e3       	ldi	r30, 0x3F	; 63
 1f0:	fc e9       	ldi	r31, 0x9C	; 156
 1f2:	31 97       	sbiw	r30, 0x01	; 1
 1f4:	f1 f7       	brne	.-4      	; 0x1f2 <pushKey+0x84>
 1f6:	00 c0       	rjmp	.+0      	; 0x1f8 <pushKey+0x8a>
 1f8:	00 00       	nop
				 	
				_delay_ms(20);
				while(!(*KEYBOARD_PIN & (1 << (j + 4))));
 1fa:	e0 91 83 00 	lds	r30, 0x0083
 1fe:	f0 91 84 00 	lds	r31, 0x0084
 202:	41 e0       	ldi	r20, 0x01	; 1
 204:	50 e0       	ldi	r21, 0x00	; 0
 206:	ba 01       	movw	r22, r20
 208:	02 c0       	rjmp	.+4      	; 0x20e <pushKey+0xa0>
 20a:	66 0f       	add	r22, r22
 20c:	77 1f       	adc	r23, r23
 20e:	2a 95       	dec	r18
 210:	e2 f7       	brpl	.-8      	; 0x20a <pushKey+0x9c>
 212:	9b 01       	movw	r18, r22
 214:	40 81       	ld	r20, Z
 216:	50 e0       	ldi	r21, 0x00	; 0
 218:	42 23       	and	r20, r18
 21a:	53 23       	and	r21, r19
 21c:	45 2b       	or	r20, r21
 21e:	d1 f3       	breq	.-12     	; 0x214 <pushKey+0xa6>
 220:	13 c0       	rjmp	.+38     	; 0x248 <pushKey+0xda>
	
	for(i = 0; i < 4; i++)
	{
		*KEYBOARD_PORT &= ~(1 << i);

		for(j = 0; j < 4; j++)
 222:	01 96       	adiw	r24, 0x01	; 1
 224:	84 30       	cpi	r24, 0x04	; 4
 226:	91 05       	cpc	r25, r1
 228:	09 f0       	breq	.+2      	; 0x22c <pushKey+0xbe>
 22a:	bf cf       	rjmp	.-130    	; 0x1aa <pushKey+0x3c>
				
				return key;
			}
		}

		*KEYBOARD_PORT |= (1 << i);
 22c:	e0 91 85 00 	lds	r30, 0x0085
 230:	f0 91 86 00 	lds	r31, 0x0086
 234:	80 81       	ld	r24, Z
 236:	a8 2b       	or	r26, r24
 238:	a0 83       	st	Z, r26
}

char pushKey() {
	int i, j;
	
	for(i = 0; i < 4; i++)
 23a:	6f 5f       	subi	r22, 0xFF	; 255
 23c:	7f 4f       	sbci	r23, 0xFF	; 255
 23e:	64 30       	cpi	r22, 0x04	; 4
 240:	71 05       	cpc	r23, r1
 242:	09 f0       	breq	.+2      	; 0x246 <pushKey+0xd8>
 244:	9a cf       	rjmp	.-204    	; 0x17a <pushKey+0xc>
		}

		*KEYBOARD_PORT |= (1 << i);
	}
	
	return 0;
 246:	80 e0       	ldi	r24, 0x00	; 0
 248:	df 91       	pop	r29
 24a:	cf 91       	pop	r28
 24c:	08 95       	ret

0000024e <off_led>:
    }
}

void off_led(uint8_t led)
{
	PORTB &= ~(1 << led);
 24e:	98 b3       	in	r25, 0x18	; 24
 250:	21 e0       	ldi	r18, 0x01	; 1
 252:	30 e0       	ldi	r19, 0x00	; 0
 254:	02 c0       	rjmp	.+4      	; 0x25a <off_led+0xc>
 256:	22 0f       	add	r18, r18
 258:	33 1f       	adc	r19, r19
 25a:	8a 95       	dec	r24
 25c:	e2 f7       	brpl	.-8      	; 0x256 <off_led+0x8>
 25e:	20 95       	com	r18
 260:	92 23       	and	r25, r18
 262:	98 bb       	out	0x18, r25	; 24
 264:	08 95       	ret

00000266 <on_led>:
}

void on_led(uint8_t led)
{
	PORTB |= (1 << led);
 266:	48 b3       	in	r20, 0x18	; 24
 268:	21 e0       	ldi	r18, 0x01	; 1
 26a:	30 e0       	ldi	r19, 0x00	; 0
 26c:	b9 01       	movw	r22, r18
 26e:	02 c0       	rjmp	.+4      	; 0x274 <on_led+0xe>
 270:	66 0f       	add	r22, r22
 272:	77 1f       	adc	r23, r23
 274:	8a 95       	dec	r24
 276:	e2 f7       	brpl	.-8      	; 0x270 <on_led+0xa>
 278:	cb 01       	movw	r24, r22
 27a:	84 2b       	or	r24, r20
 27c:	88 bb       	out	0x18, r24	; 24
 27e:	08 95       	ret

00000280 <checkNewCode>:
int checkNewCode(char *new_code)
{
	int i;
	
	for(i = 0; i < CODE_LENGTH; i++)
		if(new_code[i] == 0)
 280:	fc 01       	movw	r30, r24
 282:	20 81       	ld	r18, Z
 284:	22 23       	and	r18, r18
 286:	61 f0       	breq	.+24     	; 0x2a0 <checkNewCode+0x20>
 288:	31 96       	adiw	r30, 0x01	; 1

int checkNewCode(char *new_code)
{
	int i;
	
	for(i = 0; i < CODE_LENGTH; i++)
 28a:	21 e0       	ldi	r18, 0x01	; 1
 28c:	30 e0       	ldi	r19, 0x00	; 0
		if(new_code[i] == 0)
 28e:	81 91       	ld	r24, Z+
 290:	88 23       	and	r24, r24
 292:	49 f0       	breq	.+18     	; 0x2a6 <checkNewCode+0x26>

int checkNewCode(char *new_code)
{
	int i;
	
	for(i = 0; i < CODE_LENGTH; i++)
 294:	2f 5f       	subi	r18, 0xFF	; 255
 296:	3f 4f       	sbci	r19, 0xFF	; 255
 298:	24 30       	cpi	r18, 0x04	; 4
 29a:	31 05       	cpc	r19, r1
 29c:	c1 f7       	brne	.-16     	; 0x28e <checkNewCode+0xe>
 29e:	06 c0       	rjmp	.+12     	; 0x2ac <checkNewCode+0x2c>
		if(new_code[i] == 0)
			return 0;
 2a0:	80 e0       	ldi	r24, 0x00	; 0
 2a2:	90 e0       	ldi	r25, 0x00	; 0
 2a4:	08 95       	ret
 2a6:	80 e0       	ldi	r24, 0x00	; 0
 2a8:	90 e0       	ldi	r25, 0x00	; 0
 2aa:	08 95       	ret
	
	return 1;
 2ac:	81 e0       	ldi	r24, 0x01	; 1
 2ae:	90 e0       	ldi	r25, 0x00	; 0
}
 2b0:	08 95       	ret

000002b2 <setNewCode>:

void setNewCode(char *new_code)
{
 2b2:	fc 01       	movw	r30, r24
	int i;
	
	for(i = 0; i < CODE_LENGTH; i++)
 2b4:	20 e0       	ldi	r18, 0x00	; 0
 2b6:	30 e0       	ldi	r19, 0x00	; 0
		code[i] = new_code[i];
 2b8:	81 91       	ld	r24, Z+
 2ba:	a0 91 60 00 	lds	r26, 0x0060
 2be:	b0 91 61 00 	lds	r27, 0x0061
 2c2:	a2 0f       	add	r26, r18
 2c4:	b3 1f       	adc	r27, r19
 2c6:	8c 93       	st	X, r24

void setNewCode(char *new_code)
{
	int i;
	
	for(i = 0; i < CODE_LENGTH; i++)
 2c8:	2f 5f       	subi	r18, 0xFF	; 255
 2ca:	3f 4f       	sbci	r19, 0xFF	; 255
 2cc:	24 30       	cpi	r18, 0x04	; 4
 2ce:	31 05       	cpc	r19, r1
 2d0:	99 f7       	brne	.-26     	; 0x2b8 <setNewCode+0x6>
		code[i] = new_code[i];
}
 2d2:	08 95       	ret

000002d4 <goodCode>:
int goodCode()
{
	int i;
	
	for(i = 0; i < CODE_LENGTH; i++)
		if(code[i] != writeCode[i])
 2d4:	a0 91 60 00 	lds	r26, 0x0060
 2d8:	b0 91 61 00 	lds	r27, 0x0061
 2dc:	9c 91       	ld	r25, X
 2de:	80 91 8d 00 	lds	r24, 0x008D
 2e2:	98 13       	cpse	r25, r24
 2e4:	0d c0       	rjmp	.+26     	; 0x300 <goodCode+0x2c>
 2e6:	11 96       	adiw	r26, 0x01	; 1
 2e8:	ee e8       	ldi	r30, 0x8E	; 142
 2ea:	f0 e0       	ldi	r31, 0x00	; 0
 2ec:	81 e9       	ldi	r24, 0x91	; 145
 2ee:	90 e0       	ldi	r25, 0x00	; 0
 2f0:	3d 91       	ld	r19, X+
 2f2:	21 91       	ld	r18, Z+
 2f4:	32 13       	cpse	r19, r18
 2f6:	07 c0       	rjmp	.+14     	; 0x306 <goodCode+0x32>

int goodCode()
{
	int i;
	
	for(i = 0; i < CODE_LENGTH; i++)
 2f8:	e8 17       	cp	r30, r24
 2fa:	f9 07       	cpc	r31, r25
 2fc:	c9 f7       	brne	.-14     	; 0x2f0 <goodCode+0x1c>
 2fe:	06 c0       	rjmp	.+12     	; 0x30c <goodCode+0x38>
		if(code[i] != writeCode[i])
			return 0;
 300:	80 e0       	ldi	r24, 0x00	; 0
 302:	90 e0       	ldi	r25, 0x00	; 0
 304:	08 95       	ret
 306:	80 e0       	ldi	r24, 0x00	; 0
 308:	90 e0       	ldi	r25, 0x00	; 0
 30a:	08 95       	ret
	
	return 1;
 30c:	81 e0       	ldi	r24, 0x01	; 1
 30e:	90 e0       	ldi	r25, 0x00	; 0
}
 310:	08 95       	ret

00000312 <clearCode>:
void clearCode()
{
	int i;
	
	for(i = 0; i < CODE_LENGTH; i++)
		writeCode[i] = 0;
 312:	10 92 8d 00 	sts	0x008D, r1
 316:	10 92 8e 00 	sts	0x008E, r1
 31a:	10 92 8f 00 	sts	0x008F, r1
 31e:	10 92 90 00 	sts	0x0090, r1
		
	witchNumber = 0;
 322:	10 92 82 00 	sts	0x0082, r1
	my_codeMode = putCode;
 326:	10 92 8c 00 	sts	0x008C, r1
 32a:	08 95       	ret

0000032c <moveServo>:
	off_led(LED_GREEN);
	on_led(LED_RED);
}

void moveServo()
{
 32c:	82 e3       	ldi	r24, 0x32	; 50
 32e:	90 e0       	ldi	r25, 0x00	; 0
	
	for(i = 0; i < 50; i++)
	{
		PORTB |= (1 << SERVO_PIN);
		
		if(my_servo.servo_time == SERVO_MIN)
 330:	e9 e8       	ldi	r30, 0x89	; 137
 332:	f0 e0       	ldi	r31, 0x00	; 0
	else
		time = 1000;
	
	for(i = 0; i < 50; i++)
	{
		PORTB |= (1 << SERVO_PIN);
 334:	c0 9a       	sbi	0x18, 0	; 24
		
		if(my_servo.servo_time == SERVO_MIN)
 336:	20 81       	ld	r18, Z
 338:	31 81       	ldd	r19, Z+1	; 0x01
 33a:	28 3c       	cpi	r18, 0xC8	; 200
 33c:	31 05       	cpc	r19, r1
 33e:	39 f4       	brne	.+14     	; 0x34e <moveServo+0x22>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 340:	af e8       	ldi	r26, 0x8F	; 143
 342:	b1 e0       	ldi	r27, 0x01	; 1
 344:	11 97       	sbiw	r26, 0x01	; 1
 346:	f1 f7       	brne	.-4      	; 0x344 <moveServo+0x18>
 348:	00 c0       	rjmp	.+0      	; 0x34a <moveServo+0x1e>
 34a:	00 00       	nop
 34c:	06 c0       	rjmp	.+12     	; 0x35a <moveServo+0x2e>
 34e:	af ec       	ldi	r26, 0xCF	; 207
 350:	b7 e0       	ldi	r27, 0x07	; 7
 352:	11 97       	sbiw	r26, 0x01	; 1
 354:	f1 f7       	brne	.-4      	; 0x352 <moveServo+0x26>
 356:	00 c0       	rjmp	.+0      	; 0x358 <moveServo+0x2c>
 358:	00 00       	nop
			_delay_us(200);
		else
			_delay_us(1000);
		
		PORTB &= ~(1 << SERVO_PIN);
 35a:	c0 98       	cbi	0x18, 0	; 24
		
		if(my_servo.servo_time == SERVO_MIN)
 35c:	20 81       	ld	r18, Z
 35e:	31 81       	ldd	r19, Z+1	; 0x01
 360:	28 3c       	cpi	r18, 0xC8	; 200
 362:	31 05       	cpc	r19, r1
 364:	39 f4       	brne	.+14     	; 0x374 <moveServo+0x48>
 366:	af ea       	ldi	r26, 0xAF	; 175
 368:	ba e9       	ldi	r27, 0x9A	; 154
 36a:	11 97       	sbiw	r26, 0x01	; 1
 36c:	f1 f7       	brne	.-4      	; 0x36a <moveServo+0x3e>
 36e:	00 c0       	rjmp	.+0      	; 0x370 <moveServo+0x44>
 370:	00 00       	nop
 372:	06 c0       	rjmp	.+12     	; 0x380 <moveServo+0x54>
 374:	af e6       	ldi	r26, 0x6F	; 111
 376:	b4 e9       	ldi	r27, 0x94	; 148
 378:	11 97       	sbiw	r26, 0x01	; 1
 37a:	f1 f7       	brne	.-4      	; 0x378 <moveServo+0x4c>
 37c:	00 c0       	rjmp	.+0      	; 0x37e <moveServo+0x52>
 37e:	00 00       	nop
 380:	01 97       	sbiw	r24, 0x01	; 1
	if(my_servo.servo_time == SERVO_MIN)
		time = 200;
	else
		time = 1000;
	
	for(i = 0; i < 50; i++)
 382:	00 97       	sbiw	r24, 0x00	; 0
 384:	b9 f6       	brne	.-82     	; 0x334 <moveServo+0x8>
		if(my_servo.servo_time == SERVO_MIN)
			_delay_us(20000 - 200);
		else
			_delay_us(20000 - 1000);
	}
 386:	08 95       	ret

00000388 <openDoor>:
	my_codeMode = putCode;
}

void openDoor()
{
	my_servo.servo_time = SERVO_MAX; // w us
 388:	88 ee       	ldi	r24, 0xE8	; 232
 38a:	93 e0       	ldi	r25, 0x03	; 3
 38c:	90 93 8a 00 	sts	0x008A, r25
 390:	80 93 89 00 	sts	0x0089, r24
	moveServo();
 394:	cb df       	rcall	.-106    	; 0x32c <moveServo>
	my_servo.servo_position = 1;
 396:	81 e0       	ldi	r24, 0x01	; 1
 398:	80 93 8b 00 	sts	0x008B, r24
	
	off_led(LED_RED);
 39c:	82 e0       	ldi	r24, 0x02	; 2
 39e:	57 df       	rcall	.-338    	; 0x24e <off_led>
	on_led(LED_GREEN);
 3a0:	81 e0       	ldi	r24, 0x01	; 1
 3a2:	61 df       	rcall	.-318    	; 0x266 <on_led>
 3a4:	08 95       	ret

000003a6 <closeDoor>:
}

void closeDoor()
{
	my_servo.servo_time = SERVO_MIN; // w us
 3a6:	88 ec       	ldi	r24, 0xC8	; 200
 3a8:	90 e0       	ldi	r25, 0x00	; 0
 3aa:	90 93 8a 00 	sts	0x008A, r25
 3ae:	80 93 89 00 	sts	0x0089, r24
	moveServo();
 3b2:	bc df       	rcall	.-136    	; 0x32c <moveServo>
	my_servo.servo_position = 0;
 3b4:	10 92 8b 00 	sts	0x008B, r1
	
	off_led(LED_GREEN);
 3b8:	81 e0       	ldi	r24, 0x01	; 1
 3ba:	49 df       	rcall	.-366    	; 0x24e <off_led>
	on_led(LED_RED);
 3bc:	82 e0       	ldi	r24, 0x02	; 2
 3be:	53 df       	rcall	.-346    	; 0x266 <on_led>
 3c0:	08 95       	ret

000003c2 <main>:
void on_led(uint8_t);
void off_led(uint8_t);

int main(void)
{
	DDRB = (1 << LED_RED) | (1 << LED_GREEN) | (1 << SERVO_PIN); // PD6 is OUTPUT other in
 3c2:	87 e0       	ldi	r24, 0x07	; 7
 3c4:	87 bb       	out	0x17, r24	; 23
	PORTB = ~((1 << LED_RED) | (1 << LED_GREEN) | (1 << SERVO_PIN)); // do IN podciagniete rezystory a OUT = low
 3c6:	88 ef       	ldi	r24, 0xF8	; 248
 3c8:	88 bb       	out	0x18, r24	; 24

	setPorts(&DDRD, &PORTD, &PIND);
 3ca:	40 e3       	ldi	r20, 0x30	; 48
 3cc:	50 e0       	ldi	r21, 0x00	; 0
 3ce:	62 e3       	ldi	r22, 0x32	; 50
 3d0:	70 e0       	ldi	r23, 0x00	; 0
 3d2:	81 e3       	ldi	r24, 0x31	; 49
 3d4:	90 e0       	ldi	r25, 0x00	; 0
 3d6:	b5 de       	rcall	.-662    	; 0x142 <setPorts>
	
	LCD_Initalize();   //inicjalizacja LCD
 3d8:	7c de       	rcall	.-776    	; 0xd2 <LCD_Initalize>
// Funkcja ustawienia wspó³rzêdnych ekranowych
//
//-------------------------------------------------------------------------------------------------
void LCD_GoTo(unsigned char x, unsigned char y)
{
LCD_WriteCommand(HD44780_DDRAM_SET | (x + (0x40 * y)));
 3da:	80 e8       	ldi	r24, 0x80	; 128
 3dc:	66 de       	rcall	.-820    	; 0xaa <LCD_WriteCommand>
	LCD_GoTo(0, 0);      //Ustawienie kursora w pozycji (0,0)
	LCD_WriteText("Kutass!!!");
 3de:	82 e7       	ldi	r24, 0x72	; 114
 3e0:	90 e0       	ldi	r25, 0x00	; 0
 3e2:	69 de       	rcall	.-814    	; 0xb6 <LCD_WriteText>

	my_servo.servo_time = 1000;
 3e4:	88 ee       	ldi	r24, 0xE8	; 232
 3e6:	93 e0       	ldi	r25, 0x03	; 3
 3e8:	90 93 8a 00 	sts	0x008A, r25
 3ec:	80 93 89 00 	sts	0x0089, r24
	my_servo.servo_position = 1;
 3f0:	81 e0       	ldi	r24, 0x01	; 1
 3f2:	80 93 8b 00 	sts	0x008B, r24

	my_codeMode = putCode;
 3f6:	10 92 8c 00 	sts	0x008C, r1

	// przy starcie programu zawsze closeDoor();
	closeDoor();
 3fa:	d5 df       	rcall	.-86     	; 0x3a6 <closeDoor>
	clearCode();
 3fc:	8a df       	rcall	.-236    	; 0x312 <clearCode>
		{
			switch(key)
			{
				case 'A':
				{
					my_codeMode = changeCode;
 3fe:	11 e0       	ldi	r17, 0x01	; 1
				{
					if(my_codeMode == putCode)
					{
						if(goodCode())
						{
							if(my_servo.servo_position == 0)
 400:	cb e8       	ldi	r28, 0x8B	; 139
 402:	d0 e0       	ldi	r29, 0x00	; 0
	closeDoor();
	clearCode();

    while(1)
    {
		char key = pushKey();
 404:	b4 de       	rcall	.-664    	; 0x16e <pushKey>

		if(key)
 406:	88 23       	and	r24, r24
 408:	e9 f3       	breq	.-6      	; 0x404 <main+0x42>
		{
			switch(key)
 40a:	81 34       	cpi	r24, 0x41	; 65
 40c:	39 f0       	breq	.+14     	; 0x41c <main+0x5a>
 40e:	18 f4       	brcc	.+6      	; 0x416 <main+0x54>
 410:	8a 32       	cpi	r24, 0x2A	; 42
 412:	39 f0       	breq	.+14     	; 0x422 <main+0x60>
 414:	20 c0       	rjmp	.+64     	; 0x456 <main+0x94>
 416:	85 34       	cpi	r24, 0x45	; 69
 418:	a8 f3       	brcs	.-22     	; 0x404 <main+0x42>
 41a:	1d c0       	rjmp	.+58     	; 0x456 <main+0x94>
			{
				case 'A':
				{
					my_codeMode = changeCode;
 41c:	10 93 8c 00 	sts	0x008C, r17
				
					break;
 420:	f1 cf       	rjmp	.-30     	; 0x404 <main+0x42>
					break;
				}

				case '*':
				{
					if(my_codeMode == putCode)
 422:	80 91 8c 00 	lds	r24, 0x008C
 426:	81 11       	cpse	r24, r1
 428:	0a c0       	rjmp	.+20     	; 0x43e <main+0x7c>
					{
						if(goodCode())
 42a:	54 df       	rcall	.-344    	; 0x2d4 <goodCode>
 42c:	89 2b       	or	r24, r25
 42e:	89 f0       	breq	.+34     	; 0x452 <main+0x90>
						{
							if(my_servo.servo_position == 0)
 430:	88 81       	ld	r24, Y
 432:	81 11       	cpse	r24, r1
 434:	02 c0       	rjmp	.+4      	; 0x43a <main+0x78>
								openDoor();
 436:	a8 df       	rcall	.-176    	; 0x388 <openDoor>
 438:	0c c0       	rjmp	.+24     	; 0x452 <main+0x90>
							else
								closeDoor();
 43a:	b5 df       	rcall	.-150    	; 0x3a6 <closeDoor>
 43c:	0a c0       	rjmp	.+20     	; 0x452 <main+0x90>
						}
					}
					else if(my_codeMode == changeCode)
 43e:	81 30       	cpi	r24, 0x01	; 1
 440:	41 f4       	brne	.+16     	; 0x452 <main+0x90>
					{
						if(checkNewCode(&writeCode[0]))
 442:	8d e8       	ldi	r24, 0x8D	; 141
 444:	90 e0       	ldi	r25, 0x00	; 0
 446:	1c df       	rcall	.-456    	; 0x280 <checkNewCode>
 448:	89 2b       	or	r24, r25
 44a:	19 f0       	breq	.+6      	; 0x452 <main+0x90>
						{
							setNewCode(&writeCode[0]);
 44c:	8d e8       	ldi	r24, 0x8D	; 141
 44e:	90 e0       	ldi	r25, 0x00	; 0
 450:	30 df       	rcall	.-416    	; 0x2b2 <setNewCode>
						}
					}
					
					clearCode();
 452:	5f df       	rcall	.-322    	; 0x312 <clearCode>
					break;
 454:	d7 cf       	rjmp	.-82     	; 0x404 <main+0x42>
				}

				default: // wpisywanie kodu
				{
					if(witchNumber < 4)
 456:	e0 91 82 00 	lds	r30, 0x0082
 45a:	e4 30       	cpi	r30, 0x04	; 4
 45c:	98 f6       	brcc	.-90     	; 0x404 <main+0x42>
						writeCode[witchNumber++] = key;
 45e:	91 e0       	ldi	r25, 0x01	; 1
 460:	9e 0f       	add	r25, r30
 462:	90 93 82 00 	sts	0x0082, r25
 466:	f0 e0       	ldi	r31, 0x00	; 0
 468:	e3 57       	subi	r30, 0x73	; 115
 46a:	ff 4f       	sbci	r31, 0xFF	; 255
 46c:	80 83       	st	Z, r24
 46e:	ca cf       	rjmp	.-108    	; 0x404 <main+0x42>

00000470 <_exit>:
 470:	f8 94       	cli

00000472 <__stop_program>:
 472:	ff cf       	rjmp	.-2      	; 0x472 <__stop_program>
